"""Suppliers model

Revision ID: 840599ebc93f
Revises: 980e41598dd3
Create Date: 2025-09-03 10:55:09.030919

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '840599ebc93f'
down_revision = '980e41598dd3'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    bind = op.get_bind()
    inspector = sa.inspect(bind)

    # Cleanup any leftover temp tables from previous failed runs (SQLite batch mode)
    for tmp in ('_alembic_tmp_order_items', '_alembic_tmp_products', '_alembic_tmp_categories'):
        try:
            op.execute(f"DROP TABLE IF EXISTS {tmp}")
        except Exception:
            pass

    # Suppliers table (idempotent)
    if not inspector.has_table('suppliers'):
        op.create_table('suppliers',
            sa.Column('supplier_id', sa.Integer(), autoincrement=True, nullable=False),
            sa.Column('name', sa.String(length=200), nullable=False),
            sa.Column('category', sa.String(length=100), nullable=False),
            sa.Column('contact_person', sa.String(length=100), nullable=False),
            sa.Column('email', sa.String(length=120), nullable=False),
            sa.Column('phone', sa.String(length=20), nullable=False),
            sa.Column('address', sa.Text(), nullable=False),
            sa.Column('website', sa.String(length=200), nullable=True),
            sa.Column('rating', sa.Float(), nullable=True),
            sa.Column('status', sa.String(length=20), nullable=True),
            sa.Column('notes', sa.Text(), nullable=True),
            sa.Column('last_order_date', sa.DateTime(), nullable=True),
            sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
            sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
            sa.PrimaryKeyConstraint('supplier_id'),
            sa.UniqueConstraint('email', name='uq_suppliers_email')
        )

    # Categories.name column + UNIQUE index
    categories_columns = [col['name'] for col in inspector.get_columns('categories')]
    if 'name' not in categories_columns:
        op.add_column('categories', sa.Column('name', sa.String(length=100), nullable=True))
        op.execute("UPDATE categories SET name = category_name WHERE name IS NULL")
        op.alter_column('categories', 'name', nullable=False)
        # Create UNIQUE INDEX instead of UNIQUE CONSTRAINT (SQLite-safe)
        existing_indexes = [ix['name'] for ix in inspector.get_indexes('categories')]
        if 'uq_categories_name' not in existing_indexes:
            op.create_index('uq_categories_name', 'categories', ['name'], unique=True)

    # order_items.price type change (SQLite-safe)
    with op.batch_alter_table('order_items', recreate='always') as batch_op:
        batch_op.alter_column('price',
            existing_type=sa.String(length=100),
               type_=sa.Float(),
               existing_nullable=False)

    # orders columns
    op.add_column('orders', sa.Column('status', sa.Enum('PENDING', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED', 'RETURNED', name='status'), nullable=False, server_default='PENDING'))
    op.add_column('orders', sa.Column('payment_status', sa.Enum('SUCCESS', 'FAILED', 'PENDING', 'COMPLETED', 'REFUNDED', 'EXPIRED', 'CAPTURED', name='payment_status'), nullable=False, server_default='PENDING'))

    # products: add supplier_id + FK using batch recreate (SQLite-safe)
    products_columns = [col['name'] for col in inspector.get_columns('products')]
    if 'supplier_id' not in products_columns:
        with op.batch_alter_table('products', recreate='always') as batch_op:
            batch_op.add_column(sa.Column('supplier_id', sa.Integer(), nullable=True))
            batch_op.create_foreign_key(
                'fk_products_supplier_id_suppliers',
                'suppliers',
                ['supplier_id'],
                ['supplier_id']
            )

    # users columns
    op.add_column('users', sa.Column('first_name', sa.String(length=80), nullable=True))
    op.add_column('users', sa.Column('last_name', sa.String(length=80), nullable=True))
    op.add_column('users', sa.Column('phone', sa.String(length=20), nullable=True))
    op.add_column('users', sa.Column('address', sa.Text(), nullable=True))
    op.add_column('users', sa.Column('role', sa.Enum('USER', 'ADMIN', 'MANAGER', 'STAFF', name='userrole'), nullable=True, server_default='USER'))
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True, server_default='1'))
    # created_at: cannot add with non-constant default in SQLite; add nullable then backfill
    op.add_column('users', sa.Column('created_at', sa.DateTime(), nullable=True))
    op.execute("UPDATE users SET created_at = datetime('now') WHERE created_at IS NULL")
    op.add_column('users', sa.Column('last_login', sa.DateTime(), nullable=True))
    # op.add_column('users', sa.Column('last_logout', sa.DateTime(), nullable=True))  # Temporarily commented until ready to migrate

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        # batch_op.drop_column('last_logout')  # Temporarily commented until ready to migrate
        batch_op.drop_column('last_login')
        batch_op.drop_column('created_at')
        batch_op.drop_column('is_active')
        batch_op.drop_column('role')
        batch_op.drop_column('address')
        batch_op.drop_column('phone')
        batch_op.drop_column('last_name')
        batch_op.drop_column('first_name')

    # products revert (SQLite-safe)
    products_columns = [col['name'] for col in sa.inspect(op.get_bind()).get_columns('products')]
    if 'supplier_id' in products_columns:
        with op.batch_alter_table('products', recreate='always') as batch_op:
            # Drop FK then column within batch
            batch_op.drop_constraint('fk_products_supplier_id_suppliers', type_='foreignkey')
        batch_op.drop_column('supplier_id')

    op.drop_column('orders', 'payment_status')
    op.drop_column('orders', 'status')

    # order_items revert (SQLite-safe)
    with op.batch_alter_table('order_items', recreate='always') as batch_op:
        batch_op.alter_column('price',
               existing_type=sa.Float(),
            type_=sa.String(length=100),
               existing_nullable=False)

    # Drop UNIQUE INDEX and column
    existing_indexes = [ix['name'] for ix in sa.inspect(op.get_bind()).get_indexes('categories')]
    if 'uq_categories_name' in existing_indexes:
        op.drop_index('uq_categories_name', table_name='categories')
    op.drop_column('categories', 'name')

    op.drop_table('suppliers')
    # ### end Alembic commands ###
